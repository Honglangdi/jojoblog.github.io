<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面试题(208道)</title>
      <link href="/jojoblog.github.io/2023/02/12/java-mian-shi-ti-208-dao/"/>
      <url>/jojoblog.github.io/2023/02/12/java-mian-shi-ti-208-dao/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试题（208道）"><a href="#Java面试题（208道）" class="headerlink" title="Java面试题（208道）"></a>Java面试题（208道）</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>本文分为十九个模块，分别是：「<span style="color:red;"><strong>Java 基础、容器、多线程、反射、对象拷贝、Java Web 、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、MyBatis、RabbitMQ、Kafka、Zookeeper、MySQL、Redis、JVM</strong></span>」 ，如下图所示：</p><p><strong>模块图：</strong></p><img src="/jojoblog.github.io/2023/02/12/java-mian-shi-ti-208-dao/%E6%A8%A1%E5%9D%97%E5%9B%BE.png" class="">]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试题 </tag>
            
            <tag> Java面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式</title>
      <link href="/jojoblog.github.io/2023/02/11/java-she-ji-mo-shi/"/>
      <url>/jojoblog.github.io/2023/02/11/java-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="Java常用的设计模式"><a href="#Java常用的设计模式" class="headerlink" title="Java常用的设计模式"></a>Java常用的设计模式</h1><h2 id="二、七种常用的设计模式"><a href="#二、七种常用的设计模式" class="headerlink" title="二、七种常用的设计模式"></a>二、七种常用的设计模式</h2><h3 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h3><h4 id="1-1-饿汉模式（最基本的单例模式）"><a href="#1-1-饿汉模式（最基本的单例模式）" class="headerlink" title="1.1 饿汉模式（最基本的单例模式）"></a>1.1 饿汉模式（最基本的单例模式）</h4><p>类加载时，会直接实例化单例对象，以后都返回该对象的引用。</p><ul><li>缺点：类加载时，会直接实例化单例对象，不管是否使用到该单例对象，浪费内存。</li><li>优点：<strong>没有枷锁</strong>，执行<strong>效率高</strong>，<strong>线程安全</strong>的实例。</li></ul><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> Singleton<span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//创建本类的私有构造方法</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h4 id="1-2-懒汉模式"><a href="#1-2-懒汉模式" class="headerlink" title="1.2 懒汉模式"></a>1.2 懒汉模式</h4><p>不要直接在类加载时实例化，而是在调用方法时，再实例化。</p><ul><li>优点：不会占用内存</li><li>缺点：安全方面 单线程情况下，是安全的，但是在多线程下，多个线程可能同时执行singleton == null 都为true，会创建多个实例在内存中。</li></ul><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">}</span>                <span class="token keyword">private</span> <span class="token keyword">static</span> LazySingleton singleton<span class="token punctuation">;</span>                <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="1-2-1-双重检验模式"><a href="#1-2-1-双重检验模式" class="headerlink" title="1.2.1 双重检验模式"></a>1.2.1 双重检验模式</h5><p>懒汉模式(双重检验模式(线程安全，且效率高的) 把锁的粒度变小，只锁第一次初始化时)</p><ul><li>实例会在调用getInstance方法时创建，仅在第一调用初始化时需要锁住。</li></ul><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">}</span>                <span class="token keyword">private</span> <span class="token keyword">static</span> LazySingleton singleton<span class="token punctuation">;</span>                <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*            双重检验            首先先判断实例是否为null，为null则使用synchronized锁住类，            然后在同步块中，再一次判断实例是否为null，为null则初始化实例。            synchronized(需要锁的对象){}        */</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">synchronized</span><span class="token punctuation">(</span>LazySingleton <span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                        singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="1-3-内部类实现模式"><a href="#1-3-内部类实现模式" class="headerlink" title="1.3 内部类实现模式"></a>1.3 内部类实现模式</h4><p>通过静态内部类，完成单例模式的创建。</p><ul><li>在外部类加载时，并不会加载内部类，也就是不会执行new 实例()，这属于懒加载。</li><li>只有第一次调用getInstance方法时，才会加载。</li></ul><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerSingleton</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">InnerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">}</span>                <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Inner</span><span class="token punctuation">{</span>            <span class="token keyword">private</span> <span class="token keyword">static</span> InnerSingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">public</span> <span class="token keyword">static</span> InnerSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> Inner<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h4 id="1-4-枚举实现"><a href="#1-4-枚举实现" class="headerlink" title="1.4 枚举实现"></a>1.4 枚举实现</h4><p>通过枚举创建 单例模式。</p><ul><li>实现单例的最佳方法。简洁，支持自动序列化机制，防止多次实例化，但目前还没有被广泛采用。</li></ul><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumSingleton</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token function">EnumSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token punctuation">}</span>                <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">enum</span> SinEnum<span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//自定义的枚举值，如果没有该自定义枚举值，无法获取枚举对象</span>            SIN<span class="token punctuation">;</span>            <span class="token keyword">private</span> EnumSingleton es <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EnumSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">public</span> <span class="token keyword">static</span> EnumSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            SinEnum s <span class="token operator">=</span> SinEnum<span class="token punctuation">.</span>SIN<span class="token punctuation">;</span>            <span class="token keyword">return</span> s<span class="token punctuation">.</span>es<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h3 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h3><p>讲使用者和对象的生产者进行分离。</p><p>在工厂模式中，几乎都有三种角色，工厂(抽象工厂、具体工厂) 产品(抽象产品、具体产品) 使用者。使用者想要使用产品，不用自己去生产产品，把生产的动作交给工厂去做，使用者只需要从工厂提供产品的位置(方法)去拿就好。</p><h4 id="2-1-特点："><a href="#2-1-特点：" class="headerlink" title="2.1 特点："></a>2.1 <strong>特点：</strong></h4><ul><li><p>提供一种创建对象的最佳方式，在创建对象时不提供对外暴露创建逻辑，并且通过一个共同的接口来指向新创建的对象</p></li><li><p>定义一个创建对象的接口，让子类来决定实例化哪一个具体的工厂类，延迟到子类去执行</p></li><li><p>主要解决选择接口的问题</p></li><li><p>扩展性高，只增加相应工厂类即可，知道名称即可创建对象，屏蔽具体的实现，调用者只关心接口</p></li><li><p>增加需求时，需要增加具体类与工厂实现，导致类个数成倍增加，增加系统复杂度</p></li><li><p>只有需要生成复杂类对象时才需要使用工厂模式，且简单工厂模式不属于23种设计模式</p></li></ul><h4 id="工厂方法模式："><a href="#工厂方法模式：" class="headerlink" title="工厂方法模式："></a>工厂方法模式：</h4><h5 id="2-2-1-简单工厂"><a href="#2-2-1-简单工厂" class="headerlink" title="2.2.1 简单工厂"></a>2.2.1 简单工厂</h5><p> <strong>举例如下：（我们举一个发送邮件和短信的例子）</strong></p><p><strong>首先，创建二者的共同接口</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PersonAction</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>WomanFactory .java</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WomanFactory</span> <span class="token keyword">implements</span> <span class="token class-name">PersonAction</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span><span class="token string">"woman"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>ManFactory.java</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ManFactory</span> <span class="token keyword">implements</span> <span class="token class-name">PersonAction</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span><span class="token string">"man"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>PersonFactory 工厂类</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> PersonAction <span class="token function">eat</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"woman"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WomanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"man"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ManFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            Log<span class="token punctuation">.</span><span class="token function">i</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span><span class="token string">"输入类型不正确"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>使用如下</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span>View view<span class="token punctuation">)</span><span class="token punctuation">{</span>    PersonFactory personFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PersonFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    PersonAction man <span class="token operator">=</span> personFactory<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">"man"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    man<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    PersonAction woman <span class="token operator">=</span> personFactory<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">"woman"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    woman<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li><strong>简单工厂模式</strong>–顾客需要给出清单。<br>变化点在产品对象上，所以我们会抽象产品，然后通过一个工厂，根据不同的情况产生不同的产品对象。</li><li><strong>工厂方法模式</strong>–根据工厂能产生什么顾客拿什么。<br>工厂可以产生统一品牌的商品，会根据商品去抽象工厂，对每一个产品，提供一个工厂实现类。</li><li><strong>抽象工厂模式</strong>–根据工厂能产生什么顾客拿什么，但是工厂能产生的产品会有多种品牌。<br>超级工厂，可以生产不同品牌的各种产品，抽象出超级工厂，也要抽象出产品，然后根据不同的品牌给出该品牌商品的工工厂实现类。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> Java工厂模式 </tag>
            
            <tag> 懒汉式 </tag>
            
            <tag> 饿汉式 </tag>
            
            <tag> 抽象工厂 </tag>
            
            <tag> 工厂模式 </tag>
            
            <tag> 简单工厂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis轻松入门</title>
      <link href="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/"/>
      <url>/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis:REmote DIctionary Server（远程字典服务器）</p><h3 id="Redis-启动、登陆、连接"><a href="#Redis-启动、登陆、连接" class="headerlink" title="Redis 启动、登陆、连接"></a>Redis 启动、登陆、连接</h3><h6 id="redis启动"><a href="#redis启动" class="headerlink" title="redis启动"></a>redis启动</h6><pre class=" language-linux"><code class="language-linux">redis-server 配置文件位置</code></pre><p>redis 连接</p><h6 id="Linux界面连接"><a href="#Linux界面连接" class="headerlink" title="Linux界面连接"></a>Linux界面连接</h6><pre class=" language-linux"><code class="language-linux">redis-cli -p 端口号 -a 密码</code></pre><h6 id="jedis连接"><a href="#jedis连接" class="headerlink" title="jedis连接"></a>jedis连接</h6><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//连接redis服务器，192.168.0.100:6379</span>Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"ip"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//权限认证</span>jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><p><strong>官网：</strong><a href="https://redis.io/topics/data-types-intro">Redis数据介绍</a></p><h4 id="Redis的五大数据类型"><a href="#Redis的五大数据类型" class="headerlink" title="Redis的五大数据类型"></a>Redis的五大数据类型</h4><ul><li>String（字符串）<ul><li>String是Redis最基本的数据类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</li><li>String类型是二进制安全的。意思是Redis的String可以包含任何数据，比如jpg图片或者序列化对象。</li><li>String类型是Redis最基本的数据类型，一个Redis中的字符串value最多可以是512M。</li></ul></li><li>Hash（哈希，类似于java里的Map）<ul><li>hash是一个键值对集合。</li><li>hash是一个String类型的filed和value的映射表，hash特别适合用于存储对象。</li><li>类似于Java里面的Map&lt;String,Object&gt;</li></ul></li><li>List（列表）<ul><li>列表是简单的字符串列表，按照插入的顺序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li><li>他的底层实际是一个链表。</li></ul></li><li>Set（集合）<ul><li>Set是String类型的无需集合（无重复）。</li><li>它是通过HashTable实现的。</li></ul></li><li>Zset （sorted set：有序列表）<ul><li>Zset和set一样也是String类型元素的集合，切不允许重复的成员。</li><li>不同的是每个元素都会关联一个double类型的分数。</li><li>Redis正是通过分数类为集合中的成员进行从小到大的排序。</li><li>Zset的成员是唯一的，但是分数（score）却是可以重复。</li></ul></li></ul><h4 id="那里去获得Redis常见的数据类型"><a href="#那里去获得Redis常见的数据类型" class="headerlink" title="那里去获得Redis常见的数据类型"></a>那里去获得Redis常见的数据类型</h4><p><strong>官网：</strong><a href="http://redisdoc.com/">Redis命令参考大全</a></p><h4 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h4><h6 id="常用："><a href="#常用：" class="headerlink" title="常用："></a>常用：</h6><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/%E5%9B%BE%E5%83%8F1-1661353194444.jpeg" class=""><h6 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h6><ul><li>keys*   </li><li>exists key的名字   判断某个key是否存在。</li><li>move    key db  ——&gt;当前库就没有了，被移除了。</li><li>expirte    key   秒钟  ：为当前的key设置过期时间。</li><li>ttl   key     查看还有多少秒过期，**-1** 表示永不过期， <strong>-2</strong> 表示已过期。</li><li>type key    查看你的key是什么类型。</li></ul><h4 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h4><h6 id="常用命令，更多请查阅官方文档"><a href="#常用命令，更多请查阅官方文档" class="headerlink" title="常用命令，更多请查阅官方文档"></a>常用命令，更多请查阅官方文档</h6><h6 id="Redis命令参考大全"><a href="#Redis命令参考大全" class="headerlink" title="Redis命令参考大全"></a><a href="http://redisdoc.com/">Redis命令参考大全</a></h6><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/String%E5%B8%B8%E7%94%A8-1661353194444.jpeg" class=""><h6 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h6><p><strong>单值但value</strong></p><h6 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h6><ul><li>set / get / del / append / strlen</li><li>incr / decr / incrby / decrby    一定是数字才能进行加减。</li><li>getrange / setrange <ul><li>getrange:获取指定区间范围内的值，类似between……and的关系</li><li>从零到负一表示全部</li><li><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/getrange%E6%95%88%E6%9E%9C%E5%9B%BE-1661353194445.jpeg" class=""></li><li>setrange设置指定区间范围内的值，格式是setrange key值 具体值</li><li><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/setrange%E6%95%88%E6%9E%9C%E5%9B%BE-1661353194445.jpeg" class=""></li></ul></li><li>setex(set with expire) 键秒值  /  sentx(set if not exist)<ul><li>setex:设置带过期时间的key，动态设置。</li><li>setex 键 秒值 真实值</li><li><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/setex%E6%95%88%E6%9E%9C%E5%9B%BE-1661353194445.jpeg" class=""></li><li>setnx:只有在 key 不存在时设置 key 的值。</li><li><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/setnx%E6%95%88%E6%9E%9C%E5%9B%BE-1661353194445.jpeg" class=""></li></ul></li><li>mset / mget / msetnx <ul><li>mset:同时设置一个或多个 key-value 对。</li><li><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/mset%E6%95%88%E6%9E%9C%E5%9B%BE-1661353194445.jpeg" class=""></li><li>mget:获取所有(一个或多个)给定 key 的值。</li><li><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/mget%E6%95%88%E6%9E%9C%E5%9B%BE-1661353194445.jpeg" class=""></li><li>msetnx:同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</li><li><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/msetnx%E6%95%88%E6%9E%9C%E5%9B%BE-1661353194445.jpeg" class=""></li></ul></li><li>getset(先get 再set)<ul><li>getset:将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</li><li>简单一句话，先get然后立即set</li><li><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/getset%E6%95%88%E6%9E%9C%E5%9B%BE-1661353194446.jpeg" class=""></li></ul></li></ul><h4 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h4><h4 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h4><h4 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h4><h4 id="Redis有序集合Zset（sorted-set）"><a href="#Redis有序集合Zset（sorted-set）" class="headerlink" title="Redis有序集合Zset（sorted set）"></a>Redis有序集合Zset（sorted set）</h4><h3 id="Redis的复制（Master-x2F-Slave）"><a href="#Redis的复制（Master-x2F-Slave）" class="headerlink" title="Redis的复制（Master/Slave）"></a>Redis的复制（Master/Slave）</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p><strong>官 网：</strong> <a href="https://redis.io/topics/replication">Redis Replication 官网介绍  </a></p><p><strong>行话：</strong> 也就是我们所说的主从复制，主机数据更新后，根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主。</p><h4 id="能干嘛？"><a href="#能干嘛？" class="headerlink" title="能干嘛？"></a>能干嘛？</h4><ul><li>读写分离</li><li>容灾恢复</li></ul><h4 id="怎么玩？"><a href="#怎么玩？" class="headerlink" title="怎么玩？"></a>怎么玩？</h4><ol><li>配从(库)不配主(库)</li><li>从库配置：slaveof主库IP主端口<ul><li>每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件</li><li>Info replication</li></ul></li><li>修改配置文件细节操作<ul><li>拷贝多个redis.conf文件</li><li>开启daemonize yes</li><li>Pid 文件名字</li><li>指定端口</li><li>Log 文件名字</li><li>Dump.rdb名字</li></ul></li><li>常用三招<ul><li>一主二仆<ul><li>init</li><li>一个Master两个Salve</li><li>日志查看</li><li>主从问题演示</li></ul></li><li>薪火相传<ul><li>上一个Salves可以是下一个Salve的Master，Salve同样可以接收其他的Salves的连接和同步请求，那么该Salves作为了链条中下一个的Master，可以有效减轻Master的写压力。</li><li>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</li><li>Salveof 新主库IP 新主库端口</li></ul></li><li>反客为主<ul><li>SLAVEOF no one   使当前数据停止与其他数据库的同步，转为主数据库。</li></ul></li></ul></li></ol><h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><ol><li>Salve启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到Salve，以完成下一次完全同步。</li><li>全量复制：而Salve服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令一次传给Salve，完成同步。</li><li>但是，只要是重新连接Master，一次完全同步（全量复制）将被自动执行。</li></ol><h4 id="哨兵模式（Sentinel）"><a href="#哨兵模式（Sentinel）" class="headerlink" title="哨兵模式（Sentinel）"></a>哨兵模式（Sentinel）</h4><h6 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h6><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了，根据投票数自动将从库装换为主库。</p><h6 id="怎么玩？-1"><a href="#怎么玩？-1" class="headerlink" title="怎么玩？"></a>怎么玩？</h6><ul><li>调整结构，6379带着80,81</li><li>自定义的/myredis目录下新建sentinel.conf文件[ touch sentinel.conf ]，<strong>名字绝对不能写错</strong></li><li>配置哨兵，填写内容<ul><li>sentinel monitor 被监控主机名字（自己起名字） IP地址  Redis服务端口 1</li><li>上面最后一个数字 <strong>1</strong>,表示主机挂掉后Salve投票看让谁接替成为主机，得票数多的</li></ul></li><li>启动哨兵<ul><li>Redis-sentinel  /myredis/sentinel.conf [ sentinel.conf文件所在的目录 ]</li><li>上述目录依据各自实际情况配置，可能目录不同</li></ul></li><li>正常主从演示</li><li>原有的Master挂了</li><li>投票新选</li><li>重新主从继续开工，info replication 查查看</li><li>问题：如果之前的Master重新回来，会不会冲突？</li></ul><p><strong>一组sentinel能同时监控多个Master</strong></p><h4 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h4><p><strong>复制延时：</strong>  由于所有的操作都是先在Master上操作，然后同步更新到Salve上，所以从Master同步到Salve机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Salve机器数量的增加也会是这个问题更加严重。 </p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><strong>info replication  查看信息</strong></p><h6 id=""><a href="#" class="headerlink" title=""></a></h6><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/%E6%9F%A5%E7%9C%8Breplication%E4%BF%A1%E6%81%AF-1661353194446.jpg" class=""><p>开启主从复制后</p><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/%E6%9F%A5%E7%9C%8Breplication%E4%BF%A1%E6%81%AF2-1661353194446.jpg" class=""><p><strong>SLAVEOF  127.0.0.1 6379 [ 主机ip地址  Redis服务端口]</strong>   用于开启主从复制</p><h6 id="-2"><a href="#-2" class="headerlink" title=""></a></h6><img src="/jojoblog.github.io/2022/08/24/redis-qing-song-ru-men/%E5%BC%80%E5%90%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-1661353194446.jpg" class=""><h3 id="Spring-Boot整合Redis"><a href="#Spring-Boot整合Redis" class="headerlink" title="Spring Boot整合Redis"></a>Spring Boot整合Redis</h3><h6 id="加入以下依赖"><a href="#加入以下依赖" class="headerlink" title="加入以下依赖"></a>加入以下依赖</h6><pre class=" language-xml"><code class="language-xml">      <span class="token comment" spellcheck="true">&lt;!-- spring2.X集成redis所需common-pool2--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h6 id="编写redis的置文件"><a href="#编写redis的置文件" class="headerlink" title="编写redis的置文件"></a>编写redis的置文件</h6><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#Redis服务器地址</span><span class="token attr-name">spring.redis.host</span><span class="token punctuation">=</span><span class="token attr-value">192.168.44.168</span><span class="token comment" spellcheck="true">#Redis服务器连接端口</span><span class="token attr-name">spring.redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span><span class="token comment" spellcheck="true">#Redis数据库索引（默认为0）</span><span class="token attr-name">spring.redis.database</span><span class="token punctuation">=</span> <span class="token attr-value">0</span><span class="token comment" spellcheck="true">#连接超时时间（毫秒）</span><span class="token attr-name">spring.redis.timeout</span><span class="token punctuation">=</span><span class="token attr-value">1800000</span><span class="token comment" spellcheck="true">#连接池最大连接数（使用负值表示没有限制）</span><span class="token attr-name">spring.redis.lettuce.pool.max-active</span><span class="token punctuation">=</span><span class="token attr-value">20</span><span class="token comment" spellcheck="true">#最大阻塞等待时间(负数表示没限制)</span><span class="token attr-name">spring.redis.lettuce.pool.max-wait</span><span class="token punctuation">=</span><span class="token attr-value">-1</span><span class="token comment" spellcheck="true">#连接池中的最大空闲连接</span><span class="token attr-name">spring.redis.lettuce.pool.max-idle</span><span class="token punctuation">=</span><span class="token attr-value">5</span><span class="token comment" spellcheck="true">#连接池中的最小空闲连接</span><span class="token attr-name">spring.redis.lettuce.pool.min-idle</span><span class="token punctuation">=</span><span class="token attr-value">0</span></code></pre><h6 id="创建redis的配置类RedisConfig-java"><a href="#创建redis的配置类RedisConfig-java" class="headerlink" title="创建redis的配置类RedisConfig.java"></a>创建redis的配置类RedisConfig.java</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>JsonAutoDetect<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PropertyAccessor<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>fasterxml<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>databind<span class="token punctuation">.</span>ObjectMapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>CacheManager<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>CachingConfigurerSupport<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>EnableCaching<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>RedisCacheConfiguration<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>RedisCacheManager<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>RedisConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RedisTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>Jackson2JsonRedisSerializer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>RedisSerializationContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>RedisSerializer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>StringRedisSerializer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>Duration<span class="token punctuation">;</span><span class="token annotation punctuation">@EnableCaching</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token keyword">extends</span> <span class="token class-name">CachingConfigurerSupport</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RedisSerializer<span class="token operator">&lt;</span>String<span class="token operator">></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectMapper om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>PropertyAccessor<span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> JsonAutoDetect<span class="token punctuation">.</span>Visibility<span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span>ObjectMapper<span class="token punctuation">.</span>DefaultTyping<span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//key序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>redisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//value序列化</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//value hashmap序列化</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> CacheManager <span class="token function">cacheManager</span><span class="token punctuation">(</span>RedisConnectionFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RedisSerializer<span class="token operator">&lt;</span>String<span class="token operator">></span> redisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//解决查询缓存转换异常的问题</span>        ObjectMapper om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>PropertyAccessor<span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> JsonAutoDetect<span class="token punctuation">.</span>Visibility<span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        om<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span>ObjectMapper<span class="token punctuation">.</span>DefaultTyping<span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>om<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 配置序列化（解决乱码的问题）,过期时间600秒</span>        RedisCacheConfiguration config <span class="token operator">=</span> RedisCacheConfiguration<span class="token punctuation">.</span><span class="token function">defaultCacheConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">entryTtl</span><span class="token punctuation">(</span>Duration<span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">serializeKeysWith</span><span class="token punctuation">(</span>RedisSerializationContext<span class="token punctuation">.</span>SerializationPair<span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>redisSerializer<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">serializeValuesWith</span><span class="token punctuation">(</span>RedisSerializationContext<span class="token punctuation">.</span>SerializationPair<span class="token punctuation">.</span><span class="token function">fromSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">disableCachingNullValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RedisCacheManager cacheManager <span class="token operator">=</span> RedisCacheManager<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">cacheDefaults</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> cacheManager<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h6 id="使用redis"><a href="#使用redis" class="headerlink" title="使用redis"></a>使用redis</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RedisTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>core<span class="token punctuation">.</span>script<span class="token punctuation">.</span>DefaultRedisScript<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>util<span class="token punctuation">.</span>StringUtils<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>GetMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RestController<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>UUID<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/redisTest"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisTestController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLockLua"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLockLua</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span>        String uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span>        String skuId <span class="token operator">=</span> <span class="token string">"25"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 访问skuId 为25号的商品 100008348542</span>        String locKey <span class="token operator">=</span> <span class="token string">"lock:"</span> <span class="token operator">+</span> skuId<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 锁住的是每个商品的数据</span>        <span class="token comment" spellcheck="true">// 3 获取锁</span>        Boolean lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>locKey<span class="token punctuation">,</span> uuid<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第一种： lock 与过期时间中间不写任何的代码。</span>        <span class="token comment" spellcheck="true">// redisTemplate.expire("lock",10, TimeUnit.SECONDS);//设置过期时间</span>        <span class="token comment" spellcheck="true">// 如果true</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 执行的业务逻辑开始</span>            <span class="token comment" spellcheck="true">// 获取缓存中的num 数据</span>            Object value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果是空直接返回</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 使num 每次+1 放入缓存</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/*使用lua脚本来锁*/</span>            <span class="token comment" spellcheck="true">// 定义lua 脚本</span>            String script <span class="token operator">=</span> <span class="token string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 使用redis执行lua执行</span>            DefaultRedisScript<span class="token operator">&lt;</span>Long<span class="token operator">></span> redisScript <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultRedisScript</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            redisScript<span class="token punctuation">.</span><span class="token function">setScriptText</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置一下返回值类型 为Long</span>            <span class="token comment" spellcheck="true">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span>            <span class="token comment" spellcheck="true">// 那么返回字符串与0 会有发生错误。</span>            redisScript<span class="token punctuation">.</span><span class="token function">setResultType</span><span class="token punctuation">(</span>Long<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>redisScript<span class="token punctuation">,</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>locKey<span class="token punctuation">)</span><span class="token punctuation">,</span> uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 其他线程等待</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 睡眠</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 睡醒了之后，调用方法。</span>                <span class="token function">testLockLua</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"testLock"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        String uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//1获取锁，setne</span>        Boolean lock <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">,</span> uuid<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2获取锁成功、查询num的值</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">{</span>            Object value <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2.1判断num为空return</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//2.2有值就转成成int</span>            <span class="token keyword">int</span> num <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2.3把redis的num加1</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"num"</span><span class="token punctuation">,</span> <span class="token operator">++</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//2.4释放锁，del</span>            <span class="token comment" spellcheck="true">//判断比较uuid值是否一样</span>            String lockUuid <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>lockUuid<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//3获取锁失败、每隔0.1秒再获取</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">testLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span>    <span class="token keyword">public</span> String <span class="token function">testRedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//设置值到redis</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"lucy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从redis获取值</span>        String name <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis配置 </tag>
            
            <tag> Redis哨兵模式 </tag>
            
            <tag> Redis主从复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis事务与数据源</title>
      <link href="/jojoblog.github.io/2022/08/23/mybatis-shi-wu-yu-shu-ju-yuan/"/>
      <url>/jojoblog.github.io/2022/08/23/mybatis-shi-wu-yu-shu-ju-yuan/</url>
      
        <content type="html"><![CDATA[<h2 id="transactionManager"><a href="#transactionManager" class="headerlink" title="transactionManager"></a>transactionManager</h2><p>transactionManager：mybatis提交事务，回顾事务的方式</p><p>​type：事务处理的类型</p><p>​1）JDBC：表示mybatis底层是调用JDBC中的Connection对象的，commit，rollback</p><p>​2）MANAGED：把mybatis的事务处理委托给其他的容器（一个服务器软件，一个框架（Spring））</p><h2 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h2><p>DataSource：表示数据源，java体系中，规定了javax.sql.DataSource都是数据源，数据源都是connection对象</p><p>​type用来指定数据源的类型</p><p>​1）POOLED：使用连接池，mybatis会创建 PooledDataSource 类</p><p>​2）UPOOLED: 不使用连接池，每次执行 sql 的时候，先创建连接，再使用连接，最后关闭连接。</p><p>​不使用连接池，mybatis会创建一个 UnPooledDataSource 来管理 connection 对象的使用</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> MyBatis事务 </tag>
            
            <tag> MyBatis数据源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaIO流</title>
      <link href="/jojoblog.github.io/2022/08/23/javaio-liu/"/>
      <url>/jojoblog.github.io/2022/08/23/javaio-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="一、IO流"><a href="#一、IO流" class="headerlink" title="一、IO流"></a>一、IO流</h1><h2 id="IO流的概述和分类"><a href="#IO流的概述和分类" class="headerlink" title="IO流的概述和分类"></a>IO流的概述和分类</h2><h3 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h3><ul><li><p>IO：输入/输出（Input / Ouput）</p></li><li><p>​      流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输。</p></li><li><p>​       IO流就是用来处理设备间数据传输问题的</p><p>​                  常见的应用：文件复制，文件上传，文件下载</p></li></ul><h3 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h3><ul><li><p>按照数据的流向</p><p>​输入流：读数据</p><p>​输出流：写数据</p></li><li><p>按照数据的类型</p><p>​字节流</p><p>​字节输入流  ； 字节输出流</p><p>​字符流</p><p>​字符输入流  ； 字符输出流</p><p>一般来说，我们说的IO流分类是按照数据类型来分的</p></li></ul><h2 id="各种IO流"><a href="#各种IO流" class="headerlink" title="各种IO流"></a>各种IO流</h2><h3 id="1、File类"><a href="#1、File类" class="headerlink" title="1、File类"></a>1、File类</h3><h4 id="File类的构造方法"><a href="#File类的构造方法" class="headerlink" title="File类的构造方法"></a>File类的构造方法</h4><ul><li>File（String  pathname）                    通过将给定的路径字符串装换为抽象的路径名来创建新的File实例</li><li>File（String  parent，String child）    从父路径名字符串和子路径名字符串创建新的File实例</li><li>File  （File parent，String  child）       从父抽象路径和子路径名字字符串创建新的File实例</li></ul><h4 id="File类的创建功能"><a href="#File类的创建功能" class="headerlink" title="File类的创建功能"></a>File类的创建功能</h4><ul><li>public boolean createNewFile()           当具有该名称的文件不存在时，创建一个由该抽象路径命名的新空文件</li><li>public boolean mkdir()                          创建此抽象路径名命名的目录</li><li>public boolean mkdirs()                          创建由此抽象路径命名的目录，包括任何必需但不存在的父目录</li></ul><p>注意：不能根据路径名判断是否是路径还是文件，应该根据调用的方法判断</p><h4 id="File类的判断和获取功能"><a href="#File类的判断和获取功能" class="headerlink" title="File类的判断和获取功能"></a>File类的判断和获取功能</h4><ul><li>public boolean isDirectory()                  测试此抽象路径名表示的 File 是否为目录</li><li>public boolean isFile()                             测试此抽象路径名表示的File是否为文件</li><li>public boolean exists()                            测试此抽象路径名表示的File是否存在</li><li>public String  getAbsolutePath()             返回此抽象路径名的绝对路径名字符串</li><li>public String  getPath()                            将此路径名转化为路径名字符串</li><li>public String  getName()                          返回此抽象路径名表示的文件或目录的名称</li><li>public  String[]  list                                    返回此抽象路径名表示的目录中的文件和目录的名称的字符串数组</li><li>public File[]  listFiles()                                返回此抽象路径名表示的文件和目录的File对象数组</li></ul><h4 id="File-类的删除功能"><a href="#File-类的删除功能" class="headerlink" title="File 类的删除功能"></a>File 类的删除功能</h4><ul><li>public boolean delete()                            删除由此路径名表示的文件或者目录</li></ul><p>注意：如果是删除目录，目录中存在你内容，应该先删除内部文件 ，在删除目录</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归概述：以编程的角度来看，递归是指方法定义中调用方法本身的现象</p><p>递归解决问题的思路：</p><p>把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算。</p><p>递归要解决问题要找到两个内容：</p><ul><li><p>递归出口 ： 否则会出现内存溢出</p></li><li><p>递归规则 ： 与原问题相似的规模较小的问题</p><p>用递归求阶乘</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">File_text5</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//调用方法</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">jc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//输出结果</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"5 的阶乘是："</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义一个方法，用于递归求阶乘，参数为一个int类型的变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">jc</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//在方法内判断该变量的值是否为 1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//是，返回 1</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//不是，返回 n*(n-1)</span>            <span class="token keyword">return</span> n<span class="token operator">*</span><span class="token function">jc</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出结果</span><span class="token comment" spellcheck="true">//5 的阶乘是：120</span></code></pre></li></ul><h5 id="案例：遍历文件目录"><a href="#案例：遍历文件目录" class="headerlink" title="案例：遍历文件目录"></a>案例：遍历文件目录</h5><ul><li><p>需求：给定一个路径（D:\\itcast），请通过递归完成遍历该目录下的所有内容，并把所有文件的绝对路径输出在控制台</p><p>思路：</p><ol><li><p>根据给定的路径创建一个File对象</p></li><li><p>定义一个方法，用于获取给定目录下的所有内容，参数为第1步创建的File对象</p></li><li><p>获取给定的File目录下所有文件或者目录的File数组</p></li><li><p>遍历该File数组，得到每一个File对象</p></li><li><p>判断该File对象是否是目录</p><p>​是：递归调用</p><p>​不是：获取绝对路径输出在控制台</p></li><li><p>调用方法</p></li></ol></li><li><p>代码块</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> itheima<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>File<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">File_text6</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根据给定的路径创建一个File对象</span>        File srcFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:\\itcast"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用方法</span>        <span class="token function">getAllFilePath</span><span class="token punctuation">(</span>srcFile<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//定义一个方法，用于获取给定目录下的内容，参数为第1步创建的File对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getAllFilePath</span><span class="token punctuation">(</span>File srcFile<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取给定的File目录下所有文件或者目录的File数组</span>        File<span class="token punctuation">[</span><span class="token punctuation">]</span> fileArray  <span class="token operator">=</span> srcFile<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历该File数组，得到每一个File对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fileArray <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>File file <span class="token operator">:</span> fileArray<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//判断该File对象是否是目录</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//是：递归调用</span>                    <span class="token function">getAllFilePath</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//不是：获取绝对路径输出在控制台</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出结果</span><span class="token comment" spellcheck="true">//D:\itcast\java.txt</span><span class="token comment" spellcheck="true">//D:\itcast\javaSE\javase.txt</span><span class="token comment" spellcheck="true">//D:\itcast\javase.txt</span></code></pre></li></ul><pre><code></code></pre><h3 id="2、字节流"><a href="#2、字节流" class="headerlink" title="2、字节流"></a>2、字节流</h3><h4 id="字节流写数据"><a href="#字节流写数据" class="headerlink" title="字节流写数据"></a>字节流写数据</h4><h5 id="字节流抽象基类"><a href="#字节流抽象基类" class="headerlink" title="字节流抽象基类"></a>字节流抽象基类</h5><ul><li>InputStream： 这个抽象类是表示字节输入流的所有类的超类</li><li>OutputStream： 这个抽象类是表示字节输出流的所有类的超类</li><li>子类名特点：子类名称都是以其父类名作为子类名的后缀</li></ul><h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><ul><li>FileOutputStream：文件输出流用于数据写入File</li><li>FileOutputStream（String   name）：   创建文件输出流以指定的名称写入文件</li></ul><h5 id="使用字节输出流写数据的步骤"><a href="#使用字节输出流写数据的步骤" class="headerlink" title="使用字节输出流写数据的步骤"></a>使用字节输出流写数据的步骤</h5><ul><li>创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件）</li><li>调用字节输出流对象的写数据方法</li><li>释放资源（关闭此文件输出流并释放与此流相关联的任何系统资源）</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>File<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InputStream1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建字节输出流对象</span>        <span class="token comment" spellcheck="true">//FileOutputStream(String   name)：   创建文件输出流以指定的名称写入文件</span>        FileOutputStream  fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\JAVAdaima\\myfile\\src\\fos.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*            做了三件事：                A：调用系统功能创建了文件                B：创建了字节输出流对象                C：让字节输出流对象指向创建好的文件        */</span>        <span class="token comment" spellcheck="true">//void  write (int b) : 将指定的字节写入此文件输出流中</span>        fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        fos.write(57);</span><span class="token comment" spellcheck="true">//        fos.write(55);</span>        <span class="token comment" spellcheck="true">//最后都要释放资源</span>        <span class="token comment" spellcheck="true">//void close () : 关闭此文件输出流并释放与此流相关联的任何系统资源</span>        fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="字节流写数据的3种方式"><a href="#字节流写数据的3种方式" class="headerlink" title="字节流写数据的3种方式"></a>字节流写数据的3种方式</h5><ul><li><p>void  write(int b)     将指定的字节写入此文件输出流，一次写入一个字节数据</p></li><li><p>void  write(byte[]  b)      将b.length字节从指定的字节数组写入此文件输出流，一次写一个字节数组数据</p></li><li><p>void   write(byte[]  b, int off ,int len)    将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流，一次写入一个字节数组的部分数据</p></li><li><p>代码块</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>File<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//FileOutputStream (String name) : 创建文件输出流以指定的名称写入文件</span>        FileOutputStream fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\JAVAdaima\\MYByteStream\\fos.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//new File(name)</span><span class="token comment" spellcheck="true">//        FileOutputStream fos = new FileOutputStream(new File("MYByteStream\\fos.txt"));</span><span class="token comment" spellcheck="true">//        File file = new File("MYByteStream\\fos.txt");</span><span class="token comment" spellcheck="true">//        FileOutputStream fos2= new FileOutputStream(file);</span><span class="token comment" spellcheck="true">//        FileOutputStream fos2 = new FileOutputStream(new File("MYByteStream\\fos.txt"));</span>        <span class="token comment" spellcheck="true">//void  write(int b)     将指定的字节写入此文件输出流</span><span class="token comment" spellcheck="true">//        fos.write(97);</span><span class="token comment" spellcheck="true">//        fos.write(98);</span><span class="token comment" spellcheck="true">//        fos.write(99);</span><span class="token comment" spellcheck="true">//        fos.write(100);</span><span class="token comment" spellcheck="true">//        fos.write(101);</span>        <span class="token comment" spellcheck="true">//void  write(byte[]  b)      将b.length字节从指定的字节数组写入此文件输出流</span><span class="token comment" spellcheck="true">//        byte[] bys =  {97,98,99,100,101};</span>        <span class="token comment" spellcheck="true">//byte[]   getBytes()  :  返回字符串对应的字节数组</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bys <span class="token operator">=</span> <span class="token string">"abcdefg"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        fos.write(bys);</span>        <span class="token comment" spellcheck="true">//void   write(byte[]  b, int off ,int len)    将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流</span>        fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bys<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>bys<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bys<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//释放资源</span>        fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h5 id="字节流写数据的个小问题"><a href="#字节流写数据的个小问题" class="headerlink" title="字节流写数据的个小问题"></a>字节流写数据的个小问题</h5><h6 id="字节流写数据如何换行"><a href="#字节流写数据如何换行" class="headerlink" title="字节流写数据如何换行"></a>字节流写数据如何换行</h6><ul><li><p>写完数据后，加换行符</p><pre><code>Windows：\r\n</code></pre><p>​Linux：  \n</p><p>​Mac：\r</p></li></ul><h6 id="字节流写数据如何实现追加写入"><a href="#字节流写数据如何实现追加写入" class="headerlink" title="字节流写数据如何实现追加写入"></a>字节流写数据如何实现追加写入</h6><ul><li><p>​ public  FileOutputStream(String   name  ，boolean   append)</p></li><li><p>创建文件输出流以指定的名称写入文件。如果第二个参数为 true  ,则字节将写入文件的末尾而不是开头</p></li><li><p>代码块</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>File<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建字节输出流对象</span><span class="token comment" spellcheck="true">//        FileOutputStream fos = new FileOutputStream("D:\\JAVAdaima\\MYByteStream\\fos.txt");</span>        FileOutputStream fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\JAVAdaima\\MYByteStream\\fos.txt"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//写数据</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>  i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"\r\n"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//释放资源</span>        fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h5 id="字节流写数据加异常处理"><a href="#字节流写数据加异常处理" class="headerlink" title="字节流写数据加异常处理"></a>字节流写数据加异常处理</h5><ul><li><p>finally：在异常处理时提供finally块来执行所有清除操作。比如说IO流中的释放资源</p></li><li><p>特点：被finally控制的语句一定会执行，除非JVM退出</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>    可能出现异常的代码；<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">{</span>    异常的处理代码；<span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>    执行所有的清除操作；<span class="token punctuation">}</span></code></pre></li></ul><h6 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建字节输出流对象</span>        FileOutputStream fos <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\JAVAdaima\\MYByteStream\\fos.txt"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>fos <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="字节流读数据"><a href="#字节流读数据" class="headerlink" title="字节流读数据"></a>字节流读数据</h4><h5 id="字节流读数据（一次读取一个字节）"><a href="#字节流读数据（一次读取一个字节）" class="headerlink" title="字节流读数据（一次读取一个字节）"></a>字节流读数据（一次读取一个字节）</h5><ul><li><p>FileInputStream  ： 从文件系统中的文件获取输入字节</p></li><li><p>FileInputStream(String  name) :    通过打开与实际文件的链接来创建一个FileInputStream，该文件由文件系统中的路径名 name 命名</p></li><li><p>代码块</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima2<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A001</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建字节输入流对象</span>        <span class="token comment" spellcheck="true">//FileInputStream(String name)</span>        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\JAVAdaima\\MYByteStream\\fos.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用字节输入流对象的读数据方法</span>        <span class="token comment" spellcheck="true">//int read()  ：  从该输入流读取一个字符串的数据</span>        <span class="token comment" spellcheck="true">/*        //第一次读数据        int by  = fis.read();        System.out.println(by);        System.out.println((char)by);        //第二次读数据        by  = fis.read();        System.out.println(by);        System.out.println((char)by);        //再多读两次        by  = fis.read();        System.out.println(by);        by  = fis.read();        System.out.println(by);        //如果到达文件的末尾：-1        */</span>        <span class="token comment" spellcheck="true">/*        int by = fis.read();        while (by != -1) {            System.out.print((char) by);            by = fis.read();        }        */</span>        <span class="token comment" spellcheck="true">//优化上面的程序</span>        <span class="token keyword">int</span> by<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*            fis.read() : 读数据            by=fis.read()  :  把读到的数据赋值给by            by ！= -1    ： 判断读取到的数据是否是 -1         */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>by <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>by<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//释放资源</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h5 id="字节流读数据（一次读取一个字节数组）"><a href="#字节流读数据（一次读取一个字节数组）" class="headerlink" title="字节流读数据（一次读取一个字节数组）"></a>字节流读数据（一次读取一个字节数组）</h5><h6 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima2<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A003</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建字节输入流对象</span>        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\JAVAdaima\\MYByteStream\\fos.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用字节输出流对象的读取数据方法</span>        <span class="token comment" spellcheck="true">//int read (byte[] b) : 从该输入流读取最多 b.length 个字节的数据到一个字节数组</span>        <span class="token comment" spellcheck="true">/*        byte[] bys = new byte[5];        //第一次读取数据        int len = fis.read(bys);        System.out.println(len);        //String (byte[] bytes)        System.out.println(new String(bys, 0, len));        //第二次读取数据        len = fis.read(bys);        System.out.println(len);        System.out.println(new String(bys, 0, len));        //第三次读取数据        len = fis.read(bys);        System.out.println(len);        System.out.println(new String(bys, 0, len));        //再多读取两次        len = fis.read(bys);        System.out.println(len);        len = fis.read(bys);        System.out.println(len);         */</span>        <span class="token comment" spellcheck="true">//优化代码</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bys<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bys<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//释放资源</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><h5 id="字节缓冲流-1"><a href="#字节缓冲流-1" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><ul><li>BufferOutputStream    :  该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统被调用</li><li>BufferInputStream  ：    创建 BufferInputStream  将创建一个内部缓冲区数组，当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次填充很多字节</li></ul><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><ul><li>字节缓冲输出流  ：   BufferedOutputStream( OutputStream  out)</li><li>字节缓冲输入流   ：   BufferedInputStream( InputStream   in)</li></ul><h6 id="为什么构造方法需要的是字节流？而不是具体点的文件或者路径？"><a href="#为什么构造方法需要的是字节流？而不是具体点的文件或者路径？" class="headerlink" title="为什么构造方法需要的是字节流？而不是具体点的文件或者路径？"></a>为什么构造方法需要的是字节流？而不是具体点的文件或者路径？</h6><ul><li>​    字节缓冲流仅仅提供缓冲区，而真正的读写数据还得依靠基本的字节流对象进行操作</li></ul><h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima4<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ACS1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*        // 字节缓冲输出流： BufferedOutputStream(OutputStream out)//        FileOutputStream fos = new FileOutputStream("D:\\JAVAdaima\\MYByteStream\\fos1.txt");//        BufferedOutputStream bos = new BufferedOutputStream(fos);        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("D:\\JAVAdaima\\MYByteStream\\fos1.txt"));        //写数据        bos.write("Hello\r\n".getBytes());        bos.write("World\r\n".getBytes());        //释放资源        bos.close();         */</span>        <span class="token comment" spellcheck="true">//字节缓冲输入流：BufferedInputStream( InputStream in)</span>        BufferedInputStream bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\JAVAdaima\\MYByteStream\\fos1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//一次读取一个字节数据</span>        <span class="token keyword">int</span> by<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>by <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> by<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//一次读取一个字节数组的数据</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> bis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bys<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bys<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//释放资源</span>        bis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="案例：字节流复制文本文件"><a href="#案例：字节流复制文本文件" class="headerlink" title="案例：字节流复制文本文件"></a>案例：字节流复制文本文件</h5><h6 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h6><p>把 “ D:\itcast\java.txt “ 复制到模块目录下的  “ java.txt “ </p><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><ol><li><p>复制文本文件，其实就是把文本文件的内容从文件中读取出来( 数据源 ) ，然后写入另一个文本文件中 ( 目的地 )</p></li><li><p>数据源：</p><pre><code>D:\\itcast\\java.txt  ------读数据-----InputStream------FileInputStream</code></pre></li><li><p>目的地：</p><pre><code>MYByteStream\\java.txt-----写数据-----OutputStream------FileOutputStream</code></pre></li></ol><h6 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h6><ul><li>根据数据源创建字节输入流对象</li><li>根据目的地创建字节输出流对象</li><li>读写数据，复制文本文件（ 一次读取一个字节 ， 一次写入一个字节）</li><li>释放资源</li></ul><h6 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima2<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A002</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根据数据源创建字节输入流对象</span>        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\itcast\\java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根据目的地创建字节输出流对象</span>        FileOutputStream fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\JAVAdaima\\MYByteStream\\src\\java.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//读写数据，复制文本文件（ 一次读取一个字节 ， 一次写入一个字节）</span>        <span class="token keyword">int</span> by<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>by<span class="token operator">=</span>fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>by<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//释放资源</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="案例：字节流复制图片"><a href="#案例：字节流复制图片" class="headerlink" title="案例：字节流复制图片"></a>案例：字节流复制图片</h5><h6 id="需求-1"><a href="#需求-1" class="headerlink" title="需求"></a>需求</h6><p>把 “ D:\\itcast\\511.png “  复制到模块目录下的  “ 511.png”</p><h6 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h6><ul><li>根据数据源创建字节输入流对象</li><li>根据目的地创建字节输出流对象</li><li>读写数据，复制文本文件（ 一次读取一个字节数组 ， 一次写入一个字节数组）</li><li>释放资源</li></ul><h6 id="代码块-2"><a href="#代码块-2" class="headerlink" title="代码块"></a>代码块</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima2<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A004</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根据数据源创建字节输入流对象</span>        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\itcast\\511.png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//根据目的地创建字节输出流对象</span>        FileOutputStream fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:\\JAVAdaima\\MYByteStream\\511.png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//读写数据，复制图片(一次读取一个字节数组， 一次写入一个字节数组)</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bys<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            fos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bys<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//释放资源</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="案例：复制视频"><a href="#案例：复制视频" class="headerlink" title="案例：复制视频"></a>案例：复制视频</h5><h6 id="需求-2"><a href="#需求-2" class="headerlink" title="需求"></a>需求</h6><p>把  “ D:\\itcast\\123.avi”  复制到模块目录下的  “ 123.avi “</p><h6 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h6><ul><li>根据数据源创建字节输入流对象</li><li>根据目的地创建字节输出流对象</li><li>读写数据，复制视频</li><li>释放资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/jojoblog.github.io/2022/08/23/mysql-suo-yin/"/>
      <url>/jojoblog.github.io/2022/08/23/mysql-suo-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>[TOC]</p><h2 id="一、数据库性能下降的问题"><a href="#一、数据库性能下降的问题" class="headerlink" title="一、数据库性能下降的问题"></a>一、数据库性能下降的问题</h2><h3 id="数据库性能下降的表现"><a href="#数据库性能下降的表现" class="headerlink" title="数据库性能下降的表现"></a>数据库性能下降的表现</h3><ol><li>SQL慢</li><li>执行时间长</li><li>等待时间长</li></ol><h3 id="数据库性能下降的原因"><a href="#数据库性能下降的原因" class="headerlink" title="数据库性能下降的原因"></a>数据库性能下降的原因</h3><ol><li><p>查询数据过多</p></li><li><p>关联了太多的表，太多<strong>join</strong></p></li><li><p>没有利用索引</p><ol><li><p>单值索引</p></li><li><p>复合索引</p><p>条件多时，可以建共同索引（混合索引）。混合索引一般会优先使用。</p><p>有些情况下，索引不一定会被使用</p></li></ol></li><li><p>服务器调优以及各个参数设置（缓冲、线程数等）**[不重要，由专门DBA负责]**</p></li></ol><h2 id="二、常见的Join查询"><a href="#二、常见的Join查询" class="headerlink" title="二、常见的Join查询"></a>二、常见的Join查询</h2><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><h4 id="手写"><a href="#手写" class="headerlink" title="手写"></a>手写</h4><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%9B%BE.jpg" class=""><h4 id="机读"><a href="#机读" class="headerlink" title="机读"></a>机读</h4><p><span style="color:red;font-size:20px;">注意：</span>  不同版本的SQL的执行顺序会有所不同</p><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/SQL%E6%9C%BA%E8%AF%BB%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%9B%BE.jpg" class=""><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/SQL%E8%A7%A3%E6%9E%90%E5%9B%BE.jpg" class=""><h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><h4 id="joins图"><a href="#joins图" class="headerlink" title="joins图"></a>joins图</h4><h4 id="共有与独有"><a href="#共有与独有" class="headerlink" title="共有与独有"></a>共有与独有</h4><h5 id="共有"><a href="#共有" class="headerlink" title="共有"></a>共有</h5><p>满足 students.id = classes.stuid 的叫共有</p><h5 id="独有"><a href="#独有" class="headerlink" title="独有"></a>独有</h5><p>student表中所有不满足 students.id = classes.stuid 的叫连接关系的数据</p><h3 id="建表SQL"><a href="#建表SQL" class="headerlink" title="建表SQL"></a>建表SQL</h3><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE `t_dept` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `deptName` VARCHAR(30) DEFAULT NULL, `address` VARCHAR(40) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE TABLE `t_emp` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(20) DEFAULT NULL,  `age` INT(3) DEFAULT NULL, `deptId` INT(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_dept_id` (`deptId`) #CONSTRAINT `fk_dept_id` FOREIGN KEY (`deptId`) REFERENCES `t_dept` (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;   INSERT INTO t_dept(deptName,address) VALUES('华山','华山');INSERT INTO t_dept(deptName,address) VALUES('丐帮','洛阳');INSERT INTO t_dept(deptName,address) VALUES('峨眉','峨眉山');INSERT INTO t_dept(deptName,address) VALUES('武当','武当山');INSERT INTO t_dept(deptName,address) VALUES('明教','光明顶'); INSERT INTO t_dept(deptName,address) VALUES('少林','少林寺'); INSERT INTO t_emp(NAME,age,deptId) VALUES('风清扬',90,1);INSERT INTO t_emp(NAME,age,deptId) VALUES('岳不群',50,1);INSERT INTO t_emp(NAME,age,deptId) VALUES('令狐冲',24,1);  INSERT INTO t_emp(NAME,age,deptId) VALUES('洪七公',70,2);INSERT INTO t_emp(NAME,age,deptId) VALUES('乔峰',35,2); INSERT INTO t_emp(NAME,age,deptId) VALUES('灭绝师太',70,3);INSERT INTO t_emp(NAME,age,deptId) VALUES('周芷若',20,3);   INSERT INTO t_emp(NAME,age,deptId) VALUES('张三丰',100,4); INSERT INTO t_emp(NAME,age,deptId) VALUES('张无忌',25,5); INSERT INTO t_emp(NAME,age,deptId) VALUES('韦小宝',18,null); </code></pre><h3 id="7种JOIN"><a href="#7种JOIN" class="headerlink" title="7种JOIN"></a>7种JOIN</h3><pre class=" language-mysql"><code class="language-mysql"> # 1 A、B两表共有select * from t_emp a inner join t_dept b on a.deptId = b.id; # 2 A、B两表共有+A的独有select * from t_emp a left join t_dept b on a.deptId = b.id; # 3 A、B两表共有+B的独有 select * from t_emp a right join t_dept b on a.deptId = b.id; # 4 A的独有 select * from t_emp a left join t_dept b on a.deptId = b.id where b.id is null;  # 5 B的独有select * from t_emp a right join t_dept b on a.deptId = b.id where a.deptId is null;   # 6 AB全有#MySQL Full Join的实现 因为MySQL不支持FULL JOIN,下面是替代方法 #left join + union(可去除重复数据)+ right joinSELECT * FROM t_emp A LEFT JOIN t_dept B ON A.deptId = B.idUNIONSELECT * FROM t_emp A RIGHT JOIN t_dept B ON A.deptId = B.id#这里因为要联合的缘故，不能考虑到小表驱动大表的情况。只能用right join。要保证查询出来的数字要一致。# 7 A的独有+B的独有        * FROM t_emp A LEFT JOIN t_dept B ON A.deptId = B.id WHERE B.`id` IS NULLUNIONSELECT * FROM t_emp A RIGHT JOIN t_dept B ON A.deptId = B.id WHERE A.`deptId` IS NULL;</code></pre><h3 id="子查询与Join区别："><a href="#子查询与Join区别：" class="headerlink" title="子查询与Join区别："></a>子查询与Join区别：</h3><h4 id="思想上的区别："><a href="#思想上的区别：" class="headerlink" title="思想上的区别："></a>思想上的区别：</h4><h5 id="子查询理解："><a href="#子查询理解：" class="headerlink" title="子查询理解："></a>子查询理解：</h5><p>①先知道需要查询并将数据拿出来(若from 后的表也是一个子查询结果)。②在去寻找满足判断条件的数据(where,on,having 后的参数等)。而这些查询条件通常是通过子查询获得的。</p><p>子查询是一种根据结果找条件的倒推的顺序。比较好理解与判断<br>例题中：“人物”在t_emp 表中，所以第一个from 是t_emp 表。(也可以直接将子查询方法 from 后面(因为本题中的子查询中也有select 的数据),所以任然需要上述的推导过程)</p><h5 id="join理解："><a href="#join理解：" class="headerlink" title="join理解："></a>join理解：</h5><p>执行完第一步后的结果为一张新表。在将新表与 t_emp 进行下一步的 left join 关联。<br>先推出如何获得条件，再像算数题一样一步一步往下 join。可以交换顺序，但只能是因为条件间不相互关联时才能交换顺序。<br>join 比 子查询难一点<br>join 能用到索引，但是子查询出来的表会使索引失效。</p><h4 id="求所有人物对应的掌门"><a href="#求所有人物对应的掌门" class="headerlink" title="求所有人物对应的掌门:"></a>求所有人物对应的掌门:</h4><h5 id="t-dept-表"><a href="#t-dept-表" class="headerlink" title="t_dept 表"></a>t_dept 表</h5><p>id  deptName  address       CEO<br> 1       华山派          华山          2<br>…</p><h5 id="t-emp-表"><a href="#t-emp-表" class="headerlink" title="t_emp 表"></a>t_emp 表</h5><p>id  name     age  deptId<br>1  风清扬     90         1<br>…</p><h5 id="1-使用子查询-不推荐，影响后续用索引"><a href="#1-使用子查询-不推荐，影响后续用索引" class="headerlink" title="1.使用子查询(不推荐，影响后续用索引)"></a>1.使用子查询(不推荐，影响后续用索引)</h5><p>步骤：a.创建子查询  查询出每个门派对应的ceo<br>         b. 根据t_emp 对应的 deptId 关联子查询表查询出所有人物对应的 ceo</p><p>SELECT a.name,f.deptName,f.name FROM t_emp a<br>LEFT JOIN (SELECT d.<code>id</code>,e.<code>name</code> ,d.<code>deptName</code> FROM t_dept d<br>LEFT JOIN t_emp e<br>ON d.<code>CEO</code>=e.<code>id</code>) f<br>ON a.deptId = f.id</p><h5 id="2-使用join-推荐"><a href="#2-使用join-推荐" class="headerlink" title="2.使用join(推荐)"></a>2.使用join(推荐)</h5><p>步骤:a. 关联出每个人物对应的门派<br>       b.通过门派的 ceo 关联对应的掌门</p><p>SELECT e.<code>name</code>, d.<code>deptName</code>,f.<code>name</code> ceo FROM t_dept d<br>RIGHT JOIN t_emp e<br>ON d.<code>id</code> = e.<code>deptId</code>   ##第一步 —&gt;得到关联了部门的一张新的联合表<br>LEFT JOIN t_emp f<br>ON d.<code>CEO</code>=f.<code>id</code>       ##第二步  —&gt;通过新的联合表中的数据与另一张表关联</p><p>SELECT d.<code>deptName</code>, e.<code>name</code> CEO,d.<code>id</code>,f.name<br> FROM t_dept d<br>LEFT JOIN  t_emp e    //上述两个 join 交换了顺序并不影响执行。前提是两个 join 间不是依赖关系。且都跟<br>ON d.<code>CEO</code>=e.<code>id</code><br>LEFT JOIN t_emp f<br>ON f.deptId = d.<code>id</code></p><h2 id="三、索引概念"><a href="#三、索引概念" class="headerlink" title="三、索引概念"></a>三、索引概念</h2><h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><p>MySQL官方对索引的定义为：<span style="color:red;">索引（Index） </span>是帮助MySQL高效获取数据的<strong>数据结构</strong>。</p><p>可以得到索引的本质：<span style="color:red;">索引 是数据结构</span></p><p>索引的目的在于提高查询效率</p><h3 id="排好序的快速查找数据结构"><a href="#排好序的快速查找数据结构" class="headerlink" title="排好序的快速查找数据结构"></a><span style="color:red;">排好序的快速查找数据结构</span></h3><h4 id="详解（重要）"><a href="#详解（重要）" class="headerlink" title="详解（重要）"></a>详解（重要）</h4><p> 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，<br>这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%A4%BA%E4%BE%8B%E5%9B%BE.jpg" class=""><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址<br> 为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。<br>二叉树弊端之一：二叉树很可能会发生两边不平衡的情况。<br>B-TREE: (B:balance)  会自动根据两边的情况自动调节，使两端无限趋近于平衡状态。可以使性能最稳定。(myisam使用的方式)<br>    B-TREE弊端：(<strong>插入/修改</strong>操作多时，B-TREE会不断调整平衡，消耗性能)从侧面说明了索引不是越多越好。<br><span style="color:red;"><strong>B+TREE:Innodb 所使用的索引</strong> </span> </p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p style="font-size:18px;color:purple">数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。</p><h3 id="索引的保存"><a href="#索引的保存" class="headerlink" title="索引的保存"></a>索引的保存</h3><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。</p><h3 id="常见的索引"><a href="#常见的索引" class="headerlink" title="常见的索引"></a>常见的索引</h3><p><span style="color:red;">我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。 </span> 其中<span style="color:blue;">聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引</span>默认都是使用 <strong>B+树</strong>索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引（hash index）等。</p><h2 id="四、索引的优势与劣势"><a href="#四、索引的优势与劣势" class="headerlink" title="四、索引的优势与劣势"></a>四、索引的优势与劣势</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>通过索引查找数据库数据，可以提高数据检索的效率，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li><p>索引实际上也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占使用空间的</p></li><li><p>虽然索引列<span style="color:red;">&nbsp;大大提高了查询速度&nbsp;</span> ，但同时却会<span style="color:red;">&nbsp;降低更新表的速度&nbsp;</span> ，如对表进行 INSERT、UPDATE、DELETE。</p><p>因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新之后添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p></li><li><p><span style="color:red;"><strong>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花费时间建立最优秀的索引，或优化查询语句</strong> </span></p></li></ol><h2 id="五、MySQL索引结构"><a href="#五、MySQL索引结构" class="headerlink" title="五、MySQL索引结构"></a>五、MySQL索引结构</h2><h3 id="BTree索引"><a href="#BTree索引" class="headerlink" title="BTree索引"></a>BTree索引</h3><p><span style="color:red;font-size:20px;"><strong>BTree索引——Myisam的普通索引</strong></span>  </p><h4 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h4><p>【初始化介绍】<br>一颗b树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个<strong>数据项</strong>（深蓝色所示）和<strong>指针</strong>（黄色所示），<br>如磁盘块1包含数据项17和35，包含指针P1、P2、P3，<br>P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。<br><span style="color:red;"><strong>真实的数据存在于叶子节点</strong> </span> 真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。<br><span style="color:red;">非叶子节点不存储真实的数据，只存储指引搜索方向的数据项 </span> ，如17、35并不真实存在于数据表中。</p><p>【查找过程】<br>如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。</p><h4 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h4><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。</p><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%9B%BE.jpg" class=""><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/%E4%B8%8D%E5%90%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%98%E5%8C%96%E8%B6%8B%E5%8A%BF%E5%9B%BE.jpg" class=""><p>1  N  logN 分别表示数据与查询次数之间的关系。<br>常数  1<em>c 表示查询最快的方式。查询次数不随数据的增加而增加<br>变量 N 表示查询次数随数据数量的增加而增加<br>对数 logN 表示查询次数与数据数量成对数关系。 介于常数与 N 之间。<br>n</em>logN 表示使用的复合方法。</p><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h3><p><span style="color:red;font-size:20px;"><strong>B+Tree索引——innodb的普通索引</strong></span>  </p><h4 id="原理图-1"><a href="#原理图-1" class="headerlink" title="原理图"></a>原理图</h4><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/B+Tree%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" class=""><p>B+TREE 第二级的 数据并不能直接取出来，只作索引使用。在内存有限的情况下，查询效率高于 B-TREE<br>B-TREE 第二级可以直接取出来，树形结构比较重，在内存无限大的时候有优势。</p><h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><p>B+Tree与B-Tree 的区别：结论在内存有限的情况下，B+TREE 永远比 B-TREE好。无限内存则后者方便</p><p>　1）B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。(一次查询可能进行两次i/o操作)<br>　 2）在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。<br>　<br>思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ </p><ol><li>B+树的磁盘读写代价更低<br>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 </li><li>B+树的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ol><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种<strong>数据存储方式</strong>。<br>术语‘聚簇’表示<strong>数据行和相邻的键值进错的存储在一起</strong>。</p><p>如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。</p><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%9B%BE.jpg" class=""><h4 id="聚簇索引的好处："><a href="#聚簇索引的好处：" class="headerlink" title="聚簇索引的好处："></a>聚簇索引的好处：</h4><p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。</p><h4 id="聚簇索引的限制："><a href="#聚簇索引的限制：" class="headerlink" title="聚簇索引的限制："></a>聚簇索引的限制：</h4><ul><li>对于mysql数据库目前<strong>只有innodb数据引擎支持聚簇索引</strong>，而Myisam并不支持聚簇索引。</li><li>由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的<strong>主键</strong>。</li><li><strong>为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。（参考聚簇索引的好处。）</strong></li></ul><p> 这里说明了主键索引为何采用自增的方式：1、业务需求，有序。2、能使用到聚簇索引</p><h3 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE `article` (  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,  `title` varchar(200) DEFAULT NULL,  `content` text,  PRIMARY KEY (`id`),  FULLTEXT KEY `title` (`title`,`content`)) ENGINE=MyISAM DEFAULT CHARSET=utf8;</code></pre><p>不同于like方式的的查询：<br>SELECT * FROM article WHERE content LIKE ‘%查询字符串%’;<br>全文索引用match+against方式查询：<br>SELECT * FROM article WHERE MATCH(title,content) AGAINST (‘查询字符串’);</p><p>明显的提高查询效率。</p><h4 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h4><p>mysql5.6.4以前只有Myisam支持，5.6.4版本以后innodb才支持，但是官方版本不支持中文分词，需要第三方分词插件。<br>5.7以后官方支持中文分词。</p><p>随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被 solr,elasticSearch等专门的搜索引擎所替代。</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>Hash索引只有Memory, NDB两种引擎支持，Memory引擎默认支持Hash索引，如果多个hash值相同，出现哈希碰撞，那么索引以链表方式存储。<br><strong>NoSql采用此中索引结构。</strong></p><h3 id="R-Tree索引"><a href="#R-Tree索引" class="headerlink" title="R-Tree索引"></a>R-Tree索引</h3><p>R-Tree在mysql很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。</p><p>相对于b-tree，r-tree的优势在于范围查找。</p><h2 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>设定为主键后数据库会自动建立索引，innodb为聚簇索引。</strong></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE customer (id INT(10) UNSIGNED  AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name VARCHAR(200),  PRIMARY KEY(id) );# unsigned (无符号的)# 使用  AUTO_INCREMENT 关键字的列必须有索引(只要有索引就行)。 CREATE TABLE customer2 (id INT(10) UNSIGNED   ,customer_no VARCHAR(200),customer_name VARCHAR(200),  PRIMARY KEY(id) ); # 单独建主键索引：ALTER TABLE customer  add PRIMARY KEY customer(customer_no);   # 删除建主键索引：ALTER TABLE customer  drop PRIMARY KEY ;   # 修改建主键索引：# 必须先删除掉(drop)原索引，再新建(add)索引</code></pre><h3 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><strong>即一个索引只包含单个列（字段），一个表中可以有多个单列索引。</strong></p><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>索引建立成哪种索引类型？<br>根据数据引擎类型自动选择的索引类型<br>除开 <strong>innodb 引擎主键默认为聚簇索引</strong> 外。 <strong>innodb 的索引都采用的 B+TREE；</strong><br><strong>myisam 则都采用的 B-TREE索引</strong></p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre class=" language-mysql"><code class="language-mysql"># 随表一起建索引：CREATE TABLE customer (id INT(10) UNSIGNED  AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name VARCHAR(200),  PRIMARY KEY(id),  KEY (customer_name)  );# 随表一起建立的索引 索引名同 列名(customer_name)# 单独建单值索引：CREATE  INDEX idx_customer_name ON customer(customer_name);  # 删除索引：DROP INDEX idx_customer_name ;</code></pre><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><strong>索引列的值必须唯一，但允许有空值。</strong></p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre class=" language-mysql"><code class="language-mysql"># 随表一起建索引：CREATE TABLE customer (id INT(10) UNSIGNED  AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name VARCHAR(200),  PRIMARY KEY(id),  KEY (customer_name),  UNIQUE (customer_no));# 建立 唯一索引时必须保证所有的值是唯一的（除了null），若有重复数据，会报错。   # 单独建唯一索引：CREATE UNIQUE INDEX idx_customer_no ON customer(customer_no);  # 删除索引：DROP INDEX idx_customer_no on customer ;</code></pre><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><h4 id="复合索引和单值索引的区别"><a href="#复合索引和单值索引的区别" class="headerlink" title="复合索引和单值索引的区别"></a>复合索引和单值索引的区别</h4><p>复合索引：</p><pre class=" language-mysql"><code class="language-mysql">create index idx_no_name on emp(no,name);  # no 与  name 有同一个索引 idx_no_name</code></pre><p>单值索引：</p><pre class=" language-mysql"><code class="language-mysql">create index idx_no on emp(no);create index idx_name on emp(name);</code></pre><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p><strong>即一个索引包含多个列</strong></p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>在数据库操作期间，复合索引比单值索引所需要的开销更小(对于相同的多个列建索引)<br>当表的行数远大于索引列的数目时可以使用复合索引</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre class=" language-mysql"><code class="language-mysql"># 随表一起建索引：CREATE TABLE customer (id INT(10) UNSIGNED  AUTO_INCREMENT ,customer_no VARCHAR(200),customer_name VARCHAR(200),  PRIMARY KEY(id),  KEY (customer_name),  UNIQUE (customer_name),  KEY (customer_no,customer_name)); # 单独建索引：CREATE  INDEX idx_no_name ON customer(customer_no,customer_name);  # 删除索引：DROP INDEX idx_no_name  on customer ;</code></pre><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><span style="color:red;font-size:20px;font-weight:bold;">ALTER mytable ADD [UniQUE] INDEX [indexName] ON (columnname(length));</span>  </p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><span style="color:red;font-size:20px;font-weight:bold;">&nbsp;DROP INDEX&nbsp;[indexName] ON mytable;&nbsp;</span>  </p><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p><span style="color:red;font-size:20px;font-weight:bold;">&nbsp;SHOW INDEX FROM table_naem\G&nbsp;</span>  </p><p><strong>结果图：</strong></p><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%9C%E5%9B%BE.jpg" class=""><p><strong>表中字段解析：</strong></p><p> non_unique: 是否是唯一索引  1：是   0：不是<br>seq_in_index:列 在索引中的 序列。针对符合索引(一个索引对应多个列)。针对同一个复合索引 按照创建复合索引时的顺序进行排序<br>collation:<br>cardinality:<br>sub_part:<br>packed:<br>Null:是否允许 null 值<br>comment:<br>index_comment:</p><h4 id="使用ALTER命令"><a href="#使用ALTER命令" class="headerlink" title="使用ALTER命令"></a>使用ALTER命令</h4><pre class=" language-mysql"><code class="language-mysql"># 有四种方式来添加数据表的索引：ALTER TABLE tbl_name ADD PRIMARY KEY (column_list);# 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 ALTER TABLE tbl_name ADD UNIQUE index_name (column_list);# 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 ALTER TABLE tbl_name ADD INDEX index_name (column_list);# 添加普通索引，索引值可出现多次。 ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list);# 该语句指定了索引为 FULLTEXT ，用于全文索引。</code></pre><h2 id="六、需要创建索引的情况"><a href="#六、需要创建索引的情况" class="headerlink" title="六、需要创建索引的情况"></a>六、需要创建索引的情况</h2><ol><li><p>主键自动建立唯一索引</p></li><li><p>频繁作为<strong>查询条件</strong>的字段应该创建索引（where后面的语句）</p></li><li><p>查询中其与其他表关联的字段，外键关系建立索引</p><p>A 表关联 B 表：A join B  。  on 后面的连接条件 既 A 表查询 B 表的条件。所以 B 表被关联的字段建立索引能大大提高查询效率<br>因为在 join 中，join 左边的表会用每一个字段去遍历 B 表的所有的关联数据，相当于一个查询操作</p></li><li><p>单键/组合索引的选择问题，<strong>在高并发下倾向创建组合索引</strong></p></li><li><p><strong>查询中排序的字段</strong>，排序字段若通过索引去访问将大大提高排序速度</p><p>group by 和 order by 后面的字段有索引大大提高效率</p></li><li><p>查询中统计或者分组字段</p></li></ol><h2 id="七、不需要创建索引的情况"><a href="#七、不需要创建索引的情况" class="headerlink" title="七、不需要创建索引的情况"></a>七、不需要创建索引的情况</h2><ol><li><p>表记录太少</p></li><li><p>经常增删改的表 </p><p>原因： 索引提高了查询速度，但同时会降低更新表的速度，如对表INSERT、UPDATE、DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p></li><li><p>Where条件里用不到的字段不创建索引，因为索引建多了影响 <strong>增删改 的效率</strong></p></li><li><p>数据重复且且分布均匀的表字段，因此应该只为最经常排序的数据建立索引。<span style="color:red;">注意，&nbsp;</span>如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</p><img src="/jojoblog.github.io/2022/08/23/mysql-suo-yin/%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%88%97%E5%8C%85%E5%90%AB%E5%A4%A7%E9%87%8F%E9%87%8D%E5%A4%8D%E5%86%85%E5%AE%B9%E7%B4%A2%E5%BC%95%E6%95%88%E6%9E%9C%E5%9B%BE.jpg" class=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQLIndex </tag>
            
            <tag> MySQLGrammar </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的简单上手</title>
      <link href="/jojoblog.github.io/2022/08/23/git-de-jian-dan-shang-shou/"/>
      <url>/jojoblog.github.io/2022/08/23/git-de-jian-dan-shang-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h1><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><h5 id="显示当前Git配置信息"><a href="#显示当前Git配置信息" class="headerlink" title="显示当前Git配置信息"></a>显示当前Git配置信息</h5><pre class=" language-git"><code class="language-git"><span class="token command">$ git config<span class="token parameter"> --list</span></span>credential.helper=osxkeychaincore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=truecore.ignorecase=truecore.precomposeunicode=true</code></pre><h5 id="编辑Git配置文件"><a href="#编辑Git配置文件" class="headerlink" title="编辑Git配置文件"></a>编辑Git配置文件</h5><pre class=" language-git"><code class="language-git"><span class="token command">$ git config<span class="token parameter"> -e</span>    # 针对当前仓库 </span><span class="token comment" spellcheck="true"># 或者</span><span class="token command">$ git config<span class="token parameter"> -e</span><span class="token parameter"> --global</span>   # 针对系统上所有仓库</span></code></pre><h5 id="设置交代码时的用户信息"><a href="#设置交代码时的用户信息" class="headerlink" title="设置交代码时的用户信息"></a>设置交代码时的用户信息</h5><pre class=" language-git"><code class="language-git"><span class="token command">$ git config<span class="token parameter"> --global</span> user.name </span><span class="token string">"runoob"</span><span class="token command">$ git config<span class="token parameter"> --global</span> user.email test@runoob.com</span></code></pre><h3 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h3><h5 id="一个简单的操作步骤："><a href="#一个简单的操作步骤：" class="headerlink" title="一个简单的操作步骤："></a>一个简单的操作步骤：</h5><pre class=" language-git"><code class="language-git"><span class="token command">$ git init      # 初始化仓库。</span><span class="token command">$ git add .     # 添加文件到暂存区。</span><span class="token command">$ git commit    # 将暂存区内容添加到仓库中。</span></code></pre><h5 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库:"></a>初始化仓库:</h5><pre class=" language-git"><code class="language-git">$ mkdir runoob$ cd runoob/<span class="token command">$ git init</span>Initialized empty Git repository in /Users/tianqixin/www/runoob/.git/<span class="token comment" spellcheck="true"># 初始化空 Git 仓库完毕。</span></code></pre><h5 id="拷贝一份远程仓库"><a href="#拷贝一份远程仓库" class="headerlink" title="拷贝一份远程仓库"></a>拷贝一份远程仓库</h5><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true"># git clone [url]</span><span class="token command">$ git clone https://github.com/tianqixin/runoob-git-test</span>Cloning into <span class="token string">'runoob-git-test'</span>...remote: Enumerating objects: 12, done.remote: Total 12 (delta 0), reused 0 (delta 0), pack-reused 12Unpacking objects: 100% (12/12), done.</code></pre><h5 id="查看仓库有变更的文件"><a href="#查看仓库有变更的文件" class="headerlink" title="查看仓库有变更的文件:"></a>查看仓库有变更的文件:</h5><pre class=" language-git"><code class="language-git"><span class="token command">$ git status</span>On branch masterInitial commitChanges to be committed:  (use <span class="token string">"git rm --cached &lt;file>..."</span> to unstage)    new file:   README    new file:   hello.php    <span class="token comment" spellcheck="true"># 通常我们使用 -s 参数来获得简短的输出结果：</span><span class="token command">$ git status<span class="token parameter"> -s</span></span>AM READMEA  hello.php</code></pre><h5 id="将文件添加到暂存区："><a href="#将文件添加到暂存区：" class="headerlink" title="将文件添加到暂存区："></a>将文件添加到暂存区：</h5><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true"># 添加一个或多个文件到暂存区：</span>git add [file1] [file2] ...<span class="token comment" spellcheck="true"># 添加指定目录到暂存区，包括子目录：</span>git add [dir]<span class="token comment" spellcheck="true"># 添加当前目录下的所有文件到暂存区：</span>git add .<span class="token comment" spellcheck="true"># 以下实例我们添加两个文件：</span>$ touch README                # 创建文件$ touch hello.php             # 创建文件$ lsREADME        hello.php<span class="token command">$ git status<span class="token parameter"> -s</span></span>?? README?? hello.php$ </code></pre><h5 id="将暂存区内容添加到本地仓库中："><a href="#将暂存区内容添加到本地仓库中：" class="headerlink" title="将暂存区内容添加到本地仓库中："></a>将暂存区内容添加到本地仓库中：</h5><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true"># 提交暂存区到本地仓库中:</span>git commit -m [message]<span class="token comment" spellcheck="true"># [message] 可以是一些备注信息。</span><span class="token comment" spellcheck="true"># 提交暂存区的指定文件到仓库区：</span><span class="token command">$ git commit [file1] [file2] ...<span class="token parameter"> -m</span> [message]</span><span class="token comment" spellcheck="true"># -a 参数设置修改文件后不需要执行 git add 命令，直接来提交</span><span class="token command">$ git commit<span class="token parameter"> -a</span></span></code></pre><h5 id="从远程获取代码库："><a href="#从远程获取代码库：" class="headerlink" title="从远程获取代码库："></a>从远程获取代码库：</h5><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true"># 从远端仓库提取数据并尝试合并到当前分支：</span>git merge<span class="token comment" spellcheck="true"># 该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。</span><span class="token comment" spellcheck="true"># 假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行:</span>git fetch [alias]<span class="token comment" spellcheck="true"># 以上命令告诉 Git 去获取它有你没有的数据，然后你可以执行：</span>git merge [alias]/[branch]</code></pre><h5 id="从远程获取代码并合并本地的版本："><a href="#从远程获取代码并合并本地的版本：" class="headerlink" title="从远程获取代码并合并本地的版本："></a>从远程获取代码并合并本地的版本：</h5><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true"># git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。</span><span class="token comment" spellcheck="true"># 命令格式如下：</span>git pull &lt;远程主机名> &lt;远程分支名>:&lt;本地分支名><span class="token comment" spellcheck="true"># 更新操作：</span><span class="token command">$ git pull</span><span class="token command">$ git pull origin</span><span class="token comment" spellcheck="true"># 将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</span>git pull origin master:brantest<span class="token comment" spellcheck="true"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span>git pull origin master</code></pre><h5 id="从将本地的分支版本上传到远程并合并："><a href="#从将本地的分支版本上传到远程并合并：" class="headerlink" title="从将本地的分支版本上传到远程并合并："></a>从将本地的分支版本上传到远程并合并：</h5><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true"># 命令格式如下：</span>git push &lt;远程主机名> &lt;本地分支名>:&lt;远程分支名><span class="token comment" spellcheck="true"># 如果本地分支名与远程分支名相同，则可以省略冒号：</span>git push &lt;远程主机名> &lt;本地分支名><span class="token comment" spellcheck="true"># 实例</span><span class="token comment" spellcheck="true"># 以下命令将本地的 master 分支推送到 origin 主机的 master 分支。</span><span class="token command">$ git push origin master</span><span class="token comment" spellcheck="true"># 相等于：</span><span class="token command">$ git push origin master:master</span><span class="token comment" spellcheck="true"># 如果本地版本与远程版本有差异，但又要强制推送可以使用 --force 参数：</span>git push --force origin master<span class="token comment" spellcheck="true"># 删除主机的分支可以使用 --delete 参数，以下命令表示删除 origin 主机的 master 分支：</span>git push origin --delete master</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitQuick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/jojoblog.github.io/2022/08/22/markdown-yu-fa/"/>
      <url>/jojoblog.github.io/2022/08/22/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdowm"><a href="#Markdowm" class="headerlink" title="Markdowm"></a>Markdowm</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>使用 # 号标记<br>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><pre class=" language-markdown"><code class="language-markdown"><span class="token title important"><span class="token punctuation">#</span> 一级标题</span><span class="token title important"><span class="token punctuation">##</span> 二级标题</span><span class="token title important"><span class="token punctuation">###</span> 三级标题</span><span class="token title important"><span class="token punctuation">####</span> 四级标题</span><span class="token title important"><span class="token punctuation">#####</span> 五级标题</span><span class="token title important"><span class="token punctuation">######</span> 六级标题</span></code></pre><p>效果（从三级标题开始演示）：</p><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。</p><p>屈平疾王听之不聪也，谗谄之蔽明也，邪曲之害公也，方正之不容也，故忧愁幽思而作《离骚》。“离骚”者，犹离忧也。夫天者，人之始也；父母者，人之本也。人穷则反本，故劳苦倦极，未尝不呼天也；疾痛惨怛，未尝不呼父母也。屈平正道直行，竭忠尽智，以事其君，谗人间之，可谓穷矣。信而见疑，忠而被谤，能无怨乎？屈平之作《离骚》，盖自怨生也。《国风》好色而不淫，《小雅》怨诽而不乱。若《离骚》者，可谓兼之矣。上称帝喾，下道齐桓，中述汤、武，以刺世事。明道德之广崇，治乱之条贯，靡不毕见。其文约，其辞微，其志洁，其行廉。其称文小而其指极大，举类迩而见义远。其志洁，故其称物芳；其行廉，故死而不容。自疏濯淖污泥之中，蝉蜕于浊秽，以浮游尘埃之外，不获世之滋垢，皭然泥而不滓者也。推此志也，虽与日月争光可也。</p><h6 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h6><pre class=" language-markdown"><code class="language-markdown"><span class="token italic"><span class="token punctuation">*</span>斜体文本<span class="token punctuation">*</span></span><span class="token italic"><span class="token punctuation">_</span>斜体文本<span class="token punctuation">_</span></span><span class="token bold"><span class="token punctuation">**</span>粗体文本<span class="token punctuation">**</span></span><span class="token bold"><span class="token punctuation">__</span>粗体文本<span class="token punctuation">__</span></span><span class="token bold"><span class="token punctuation">**</span>*粗斜体文本<span class="token punctuation">**</span></span>*<span class="token bold"><span class="token punctuation">__</span>_粗斜体文本<span class="token punctuation">__</span></span>_</code></pre><p>效果：</p><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><h6 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h6><pre class=" language-markdowm"><code class="language-markdowm">**** * ******- - -----------</code></pre><p>效果：</p><hr><hr><hr><hr><hr><h6 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h6><pre class=" language-markdowm"><code class="language-markdowm">RUNOOB.COMGOOGLE.COM~~BAIDU.COM~~</code></pre><p>效果：<br><del>BAIDU.COM</del></p><h6 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h6><pre class=" language-markdowm"><code class="language-markdowm"><u>带下划线文本</u></code></pre><p>效果：<br><u>带下划线文本</u></p><h6 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h6><pre class=" language-markdowm"><code class="language-markdowm">创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</code></pre><p>效果：<br>创建脚注格式类似这样 [^RUNOOB]。</p><p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre class=" language-markdowm"><code class="language-markdowm">* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>效果：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表使用数字并加上 . 号来表示，如：</p><pre class=" language-markdowm"><code class="language-markdowm">1. 第一项2. 第二项3. 第三项</code></pre><p>效果：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><pre class=" language-markdowm"><code class="language-markdowm">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>效果</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><h6 id="区块使用"><a href="#区块使用" class="headerlink" title="区块使用"></a>区块使用</h6><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p><pre class=" language-markdowm"><code class="language-markdowm">> 区块引用> 菜鸟教程> 学的不仅是技术更是梦想</code></pre><p>效果：</p><blockquote><p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote><h6 id="区块嵌套"><a href="#区块嵌套" class="headerlink" title="区块嵌套"></a>区块嵌套</h6><pre class=" language-markdowm"><code class="language-markdowm">> 最外层> > 第一层嵌套> > > 第二层嵌套</code></pre><p>效果：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h6 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h6><pre class=" language-markdowm"><code class="language-markdowm">> 区块中使用列表> 1. 第一项> 2. 第二项> + 第一项> + 第二项> + 第三项</code></pre><p>效果：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h6 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h6><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。</p><p>列表中使用区块实例如下：</p><pre class=" language-markdowm"><code class="language-markdowm">* 第一项    > 菜鸟教程    > 学的不仅是技术更是梦想* 第二项</code></pre><p>效果：</p><ul><li><p>第一项</p><blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li><p>第二项</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><pre class=" language-markdowm"><code class="language-markdowm">`printf()` 函数</code></pre><p>效果：<br><code>printf()</code> 函数</p><h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p><p>实例如下：</p><pre class=" language-markdowm"><code class="language-markdowm">    $(document).ready(function () {    alert('RUNOOB');});</code></pre><p>你也可以用 ‘’ ``` “ 包裹一段代码，并指定一种语言（也可以不指定）：<strong>推荐使用</strong></p><pre class=" language-markdowm"><code class="language-markdowm">\`\`\`javascript$(document).ready(function () {    alert('RUNOOB');});\`\`\`</code></pre><p>效果：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'RUNOOB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接使用方法如下：</p><blockquote><p>[链接名称](链接地址)</p><p>或者</p><p>&lt;链接地址&gt;</p></blockquote><p>链接使用方法如下：</p><pre class=" language-markdown"><code class="language-markdown">这是一个链接 <span class="token url">[菜鸟教程](https://www.runoob.com)</span>或直接使用链接地址：&lt;https://www.runoob.com></code></pre><p>效果：<br>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a><br>或<br>直接使用链接地址：</p><p><a href="https://www.runoob.com/">https://www.runoob.com</a></p><h4 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h4><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre class=" language-markdowm"><code class="language-markdowm">这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http://www.google.com/  [runoob]: http://www.runoob.com/</code></pre><p>效果：</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>Markdown 图片语法格式如下：</p><pre class=" language-markdowm"><code class="language-markdowm">![alt 属性文本](图片地址)![alt 属性文本](图片地址 "可选标题")使用实例：![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png "RUNOOB")</code></pre><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><p>效果：</p><p><img src="/jojoblog.github.io/MarkDown%E8%AF%AD%E6%B3%95/runoob-logo.png" alt="RUNOOB 图标"></p><p><img src="/jojoblog.github.io/MarkDown%E8%AF%AD%E6%B3%95/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><p>当然，你也可以像网址那样对图片网址使用变量:</p><pre class=" language-markdowm"><code class="language-markdowm">这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）[1]: http://static.runoob.com/images/runoob-logo.png</code></pre><p>效果</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.<br>然后在文档的结尾为变量赋值（网址）</p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://static.runoob.com/images/runoob-logo.png<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50%<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><img src="http://static.runoob.com/images/runoob-logo.png" width="50%"><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><pre class=" language-markdowm"><code class="language-markdowm">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>效果：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>我们可以设置表格的对齐方式：</p><blockquote><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐</p></blockquote><pre class=" language-markdowm"><code class="language-markdowm">| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre><p>效果：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h4 id="支持html元素"><a href="#支持html元素" class="headerlink" title="支持html元素"></a>支持html元素</h4><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：</sub></sup></em></i></b></kbd></p><pre class=" language-markdowm"><code class="language-markdowm">使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</code></pre><p>效果：<br>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre class=" language-markdowm"><code class="language-markdowm">**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p>效果：<br><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><blockquote><p>\   反斜线<br>`   反引号<br>*   星号<br>_   下划线<br>{}  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号</p></blockquote><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>Markdown Preview Enhanced 使用 KaTeX 或者 MathJax 来渲染数学表达式。</p><p>KaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。你可以查看 KaTeX supported functions/symbols 来了解 KaTeX 支持那些符号和函数。</p><p>默认下的分隔符：</p><blockquote><p>$…$ 或者 (…) 中的数学表达式将会在行内显示。<br>$$…$$ 或者 […] 或者 ```math 中的数学表达式将会在块内显示。</p></blockquote><pre class=" language-markdowm"><code class="language-markdowm">$$\begin{Bmatrix}   a & b \\   c & d\end{Bmatrix}$$$$\begin{CD}   A @>a>> B \\@VbVV @AAcA \\   C @= D\end{CD}$$</code></pre><hr><p>效果图：<br>$$<br>\begin{Bmatrix}<br>   a &amp; b \<br>   c &amp; d<br>\end{Bmatrix}<br>$$</p><p>$$<br>\begin{CD}<br>   A @&gt;a&gt;&gt; B \<br>@VbVV @AAcA \<br>   C @= D<br>\end{CD}<br>$$</p><hr><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><h4 id="横向流程图"><a href="#横向流程图" class="headerlink" title="横向流程图"></a>横向流程图</h4><p>代码：</p><pre class=" language-markdown"><code class="language-markdown">```mermaidgraph LRA[方形] -->B(圆角)<span class="token code keyword">    B --> C{条件a}</span><span class="token code keyword">    C -->|a=1| D[结果1]</span><span class="token code keyword">    C -->|a=2| E[结果2]</span><span class="token code keyword">    F[横向流程图]</span>```</code></pre><p>效果：</p><pre class=" language-mermaid"><code class="language-mermaid">graph LRA[方形] -->B(圆角)    B --> C{条件a}    C -->|a=1| D[结果1]    C -->|a=2| E[结果2]    F[横向流程图]</code></pre><hr><h4 id="竖向流程图"><a href="#竖向流程图" class="headerlink" title="竖向流程图"></a>竖向流程图</h4><pre class=" language-markdowm"><code class="language-markdowm">```mermaidgraph TDA[方形] --> B(圆角)    B --> C{条件a}    C --> |a=1| D[结果1]    C --> |a=2| E[结果2]    F[竖向流程图]```</code></pre><p>效果图：</p><pre class=" language-mermaid"><code class="language-mermaid">graph TDA[方形] --> B(圆角)    B --> C{条件a}    C --> |a=1| D[结果1]    C --> |a=2| E[结果2]    F[竖向流程图]</code></pre><hr><h4 id="标准流程图"><a href="#标准流程图" class="headerlink" title="标准流程图"></a>标准流程图</h4><p>代码：</p><pre class=" language-markdowm"><code class="language-markdowm">```flowst=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st->op->condcond(yes)->io->econd(no)->sub1(right)->op```</code></pre><p>效果图：</p><pre class=" language-flow"><code class="language-flow">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st->op->condcond(yes)->io->econd(no)->sub1(right)->op</code></pre><hr><h4 id="标准流程图（横向）"><a href="#标准流程图（横向）" class="headerlink" title="标准流程图（横向）"></a>标准流程图（横向）</h4><p>代码：</p><pre class=" language-markdowm"><code class="language-markdowm">```flowst=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st(right)->op(right)->condcond(yes)->io(bottom)->econd(no)->sub1(right)->op```</code></pre><p>效果图：</p><pre class=" language-flow"><code class="language-flow">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st(right)->op(right)->condcond(yes)->io(bottom)->econd(no)->sub1(right)->op</code></pre><hr><h4 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h4><p>代码</p><pre class=" language-markdowm"><code class="language-markdowm">```sequence对象A->对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B-->对象A: 我很好(响应)对象A->对象B: 你真的好吗？```</code></pre><p>效果图：</p><pre class=" language-sequence"><code class="language-sequence">对象A->对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B-->对象A: 我很好(响应)对象A->对象B: 你真的好吗？</code></pre><hr><h4 id="复杂UML时序图"><a href="#复杂UML时序图" class="headerlink" title="复杂UML时序图"></a>复杂UML时序图</h4><p>代码：</p><pre class=" language-markdowm"><code class="language-markdowm">```sequenceTitle: 标题：复杂使用对象A->对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B-->对象A: 我很好(响应)对象B->小三: 你好吗小三-->>对象A: 对象B找我了对象A->对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩```</code></pre><p>效果图：</p><pre class=" language-sequence"><code class="language-sequence">Title: 标题：复杂使用对象A->对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B-->对象A: 我很好(响应)对象B->小三: 你好吗小三-->>对象A: 对象B找我了对象A->对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩</code></pre><hr><h4 id="标准UML时序图"><a href="#标准UML时序图" class="headerlink" title="标准UML时序图"></a>标准UML时序图</h4><p>代码：</p><pre class=" language-markdowm"><code class="language-markdowm">```mermaid%% 时序图例子,-> 直线，-->虚线，->>实线箭头  sequenceDiagram    participant 张三    participant 李四    张三->王五: 王五你好吗？    loop 健康检查        王五->王五: 与疾病战斗    end    Note right of 王五: 合理 食物 <br/>看医生...    李四-->>张三: 很好!    王五->李四: 你怎么样?    李四-->王五: 很好!```</code></pre><p>效果图：</p><pre class=" language-mermaid"><code class="language-mermaid">%% 时序图例子,-> 直线，-->虚线，->>实线箭头  sequenceDiagram    participant 张三    participant 李四    张三->王五: 王五你好吗？    loop 健康检查        王五->王五: 与疾病战斗    end    Note right of 王五: 合理 食物 <br/>看医生...    李四-->>张三: 很好!    王五->李四: 你怎么样?    李四-->王五: 很好!</code></pre><hr><h4 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h4><p>代码：</p><pre class=" language-markdowm"><code class="language-markdowm">```mermaid%% 语法示例        gantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h```</code></pre><p>效果图：</p><pre class=" language-mermaid"><code class="language-mermaid">%% 语法示例        gantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h</code></pre><hr><h4 id="竖向流程图-1"><a href="#竖向流程图-1" class="headerlink" title="竖向流程图"></a>竖向流程图</h4><pre class=" language-markdowm"><code class="language-markdowm"></code></pre><h4 id="竖向流程图-2"><a href="#竖向流程图-2" class="headerlink" title="竖向流程图"></a>竖向流程图</h4><pre class=" language-markdowm"><code class="language-markdowm"></code></pre><h4 id="竖向流程图-3"><a href="#竖向流程图-3" class="headerlink" title="竖向流程图"></a>竖向流程图</h4><pre class=" language-markdowm"><code class="language-markdowm"></code></pre>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
          <category> MDGrammar </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> MDGrammar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>All Hello World</title>
      <link href="/jojoblog.github.io/2022/08/22/all-hello-world/"/>
      <url>/jojoblog.github.io/2022/08/22/all-hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Java-Quick-Start-Test"><a href="#Java-Quick-Start-Test" class="headerlink" title="Java Quick Start Test"></a>Java Quick Start Test</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="C-Quick-Start-Test"><a href="#C-Quick-Start-Test" class="headerlink" title="C Quick Start Test"></a>C Quick Start Test</h3><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* 我的第一个 C 程序 */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, World! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Python-Quick-Start-Test"><a href="#Python-Quick-Start-Test" class="headerlink" title="Python Quick Start Test"></a>Python Quick Start Test</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span></code></pre><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"我的第一个 JavaScript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> HelloWorld </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/jojoblog.github.io/2022/07/08/hello-world/"/>
      <url>/jojoblog.github.io/2022/07/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
